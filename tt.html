<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Network Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
        }

        .nodes circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }

        .highlighted {
            stroke: red;
            stroke-width: 3px;
        }

        .highlighted-link {
            stroke: red;
            stroke-opacity: 1;
            stroke-width: 3px;
        }

        .faded {
            opacity: 0.1;
        }
    </style>
</head>
<body>
    <h1>Word Network Visualization</h1>
    <svg width="960" height="600" viewBox="0 0 960 600"></svg>

    <script>
        // 기존 데이터 예시
        let existingData = {
            nodes: [
                { id: "경제" },
                { id: "사회" },
                { id: "정치" },
                { id: "과학" },
                { id: "문화" }
            ],
            links: [
                { source: "경제", target: "사회", value: 1 },
                { source: "사회", target: "정치", value: 1 },
                { source: "정치", target: "과학", value: 1 },
                { source: "경제", target: "과학", value: 1 },
                { source: "경제", target: "문화", value: 1 }
            ]
        };

        fetch('http://localhost:8000/api/youtube/correlations?url=https://www.youtube.com/watch?v=lrQLLyYg-ww')  // API 엔드포인트 URL
            .then(response => response.json())
            .then(newData => {
                // 노드 병합
                newData.nodes.forEach(newNode => {
                    if (!existingData.nodes.some(node => node.id === newNode.id)) {
                        existingData.nodes.push(newNode);
                    }
                });

                // 링크 병합
                newData.links.forEach(newLink => {
                    if (!existingData.links.some(link => link.source === newLink.source && link.target === newLink.target)) {
                        existingData.links.push(newLink);
                    }
                });

                // D3.js로 시각화 업데이트
                updateVisualization(existingData);
            });

        // D3.js 시각화 함수
        function updateVisualization(data) {
            const svg = d3.select("svg");
            const width = +svg.attr("width");
            const height = +svg.attr("height");

            // 줌과 패닝 설정
            const zoom = d3.zoom()
                .scaleExtent([0.5, 5])  // 줌 범위 설정
                .on("zoom", (event) => {
                    container.attr("transform", event.transform);
                });

            svg.call(zoom);

            const container = svg.append("g");

            const simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(data.links).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX(width / 2).strength(0.05))  // 중앙으로 집중
                .force("y", d3.forceY(height / 2).strength(0.05)); // 중앙으로 집중

            const link = container.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(data.links)
                .enter().append("line")
                .attr("stroke-width", d => Math.sqrt(d.value));

            const node = container.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(data.nodes)
                .enter().append("g");

            node.append("circle")
                .attr("r", 10)
                .attr("fill", "blue")
                .on("click", (event, d) => highlightConnectedNodes(d))  // 노드를 클릭하면 강조하는 함수 호출
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // 노드의 id 값을 표시하는 텍스트 추가
            node.append("text")
                .attr("x", 15)
                .attr("y", 3)
                .text(d => d.id);

            simulation
                .nodes(data.nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(data.links);

            function ticked() {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node.selectAll("circle")
                    .attr("cx", d => d.x)
                    .attr("cy", d => d.y);

                node.selectAll("text")
                    .attr("x", d => d.x + 15)
                    .attr("y", d => d.y + 3);
            }

            // 드래그 이벤트
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // 노드를 클릭했을 때 연결된 노드와 링크를 강조하는 함수
            function highlightConnectedNodes(selectedNode) {
                // 모든 노드와 링크를 초기 상태로 설정
                node.selectAll("circle").classed("faded", true);
                node.selectAll("text").classed("faded", true);
                link.classed("faded", true);

                // 선택된 노드와 연결된 노드 및 링크를 필터링
                const connectedLinks = data.links.filter(l => l.source.id === selectedNode.id || l.target.id === selectedNode.id);

                // 선택된 노드 및 연결된 링크/노드를 강조
                connectedLinks.forEach(l => {
                    link.filter(d => d === l).classed("highlighted-link", true).classed("faded", false);

                    node.filter(d => d.id === l.source.id || d.id === l.target.id)
                        .select("circle")
                        .classed("highlighted", true)
                        .classed("faded", false);
                        
                    node.filter(d => d.id === l.source.id || d.id === l.target.id)
                        .select("text")
                        .classed("faded", false);
                });

                // 선택된 노드 강조
                node.filter(d => d.id === selectedNode.id)
                    .select("circle")
                    .classed("highlighted", true)
                    .classed("faded", false);

                node.filter(d => d.id === selectedNode.id)
                    .select("text")
                    .classed("faded", false);
            }
        }

        // 시각화 업데이트 호출
        updateVisualization(existingData);
    </script>
</body>
</html>
